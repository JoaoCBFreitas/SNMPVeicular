/*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.array-user.conf
 *
 *
 * For help understanding NET-SNMP in general, please check the 
 *     documentation and FAQ at:
 *
 *     http://www.net-snmp.org/
 *
 *
 * For help understanding this code, the agent and how it processes
 *     requests, please check the following references.
 *
 *     http://www.net-snmp.org/tutorial-5/
 *
 *
 * You can also join the #net-snmp channel on irc.freenode.net
 *     and ask for help there.
 *
 *
 * And if all else fails, send a detailed message to the developers
 *     describing the problem you are having to:
 *
 *    net-snmp-coders@lists.sourceforge.net
 *
 *
 * Yes, there is lots of code here that you might not use. But it is much
 * easier to remove code than to add it!
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>

#include "requestMonitoringDataTable.h"

static netsnmp_handler_registration *my_handler = NULL;
static netsnmp_table_array_callbacks cb;

const oid requestMonitoringDataTable_oid[] = {requestMonitoringDataTable_TABLE_OID};
const size_t requestMonitoringDataTable_oid_len = OID_LENGTH(requestMonitoringDataTable_oid);
/*This function will delete an entry from requestMonitoringDataTable*/
int deleteRequestEntry(requestMonitoringStruct * req){
    requestMonitoringDataTable_context *ctx;
    netsnmp_index index;
    oid index_oid[2];
    index_oid[0] = req->reqID;
    index.oids = (oid *)&index_oid;
    index.len = 1;
    ctx = NULL;
    /* Search for it first. */
    ctx = CONTAINER_FIND(cb.container, &index);
    if (ctx)
    {
        CONTAINER_REMOVE(cb.container,&index);
        requestMonitoringDataTable_delete_row(ctx);
    }else{
        return 2;
    }
    ctx = CONTAINER_FIND(cb.container, &index);
    if(ctx)
        return 1;
    else
        return 0;
}
/************************************************************
 * This function inserts a requestMonitoringStruct into the requestMonitoringDataTable
 */
int insertMonitoringRow(requestMonitoringStruct* req)
{
    requestMonitoringDataTable_context *ctx;
    netsnmp_index index;
    oid index_oid[2];
    index_oid[0] = req->reqID;
    index.oids = (oid *)&index_oid;
    index.len = 1;
    ctx = NULL;
    /* Search for it first. */
    ctx = CONTAINER_FIND(cb.container, &index);
    /*Delete previous entry if it already exists*/
    if(ctx){
        CONTAINER_REMOVE(cb.container,&index);
        requestMonitoringDataTable_delete_row(ctx);
        ctx = requestMonitoringDataTable_create_row(&index, req);
        CONTAINER_INSERT(cb.container, ctx);
        return 0;
    }else{
        ctx = requestMonitoringDataTable_create_row(&index, req);
        CONTAINER_INSERT(cb.container, ctx);
        return 0;
    }
    return 1;
}


/*This function will add a row to requestControlDataTable if this table has no equivalent in requestMonitoringDataTable*/
int insertRowControl_Monitor(requestMonitoringDataTable_context *reqMonitoring){
    requestStruct *req = (requestStruct *)malloc(sizeof(requestStruct));
    req->reqID=reqMonitoring->requestID;
    req->requestControlMapID=reqMonitoring->requestControlID;
    req->settingMode=reqMonitoring->savingMode;
    req->commitTime=malloc(sizeof(char)*reqMonitoring->startTime_len+1);
    strcpy(req->commitTime,reqMonitoring->startTime);
    req->endTime=malloc(sizeof(char)*reqMonitoring->endTime_len+1);
    strcpy(req->endTime,reqMonitoring->endTime);
    req->waitTime=malloc(sizeof(char)*strlen("00:10:00")+1);
    strcpy(req->waitTime,"00:10:00");
    req->duration=malloc(sizeof(char)*reqMonitoring->durationTime_len+1);
    strcpy(req->duration,reqMonitoring->durationTime);
    req->expireTime=malloc(sizeof(char)*reqMonitoring->expireTime_len+1);
    strcpy(req->expireTime,reqMonitoring->expireTime);
    req->status=reqMonitoring->status;
    req->valuesTable=0;
    int insert=insertControlRow(req);
    free(req);
    return insert;
}
/*This function will convert a requestMonitoringDataTable_context to requestMonitoringStruct*/
requestMonitoringStruct* tableToStruct(requestMonitoringDataTable_context* reqMonitoring,requestMonitoringStruct* reqStruct){
    reqStruct->reqID=reqMonitoring->requestID;
    reqStruct->requestControlID=reqMonitoring->requestControlID;
    reqStruct->requestMapID=reqMonitoring->requestMapID;
    reqStruct->statisticsRequestID=reqMonitoring->requestStatisticsID;
    reqStruct->savingMode=reqMonitoring->savingMode;
    reqStruct->sampleFreq=reqMonitoring->samplingFrequency;
    reqStruct->maxDelay=reqMonitoring->maxDelay;
    reqStruct->startTime=malloc(sizeof(char)*strlen(reqMonitoring->startTime));
    reqStruct->endTime=malloc(sizeof(char)*strlen(reqMonitoring->endTime));
    reqStruct->durationTime=malloc(sizeof(char)*strlen(reqMonitoring->durationTime));
    reqStruct->expireTime=malloc(sizeof(char)*strlen(reqMonitoring->expireTime));
    strcpy(reqStruct->startTime,reqMonitoring->startTime);
    strcpy(reqStruct->endTime,reqMonitoring->endTime);
    strcpy(reqStruct->durationTime,reqMonitoring->durationTime);
    strcpy(reqStruct->expireTime,reqMonitoring->expireTime);
    reqStruct->maxNofSamples=reqMonitoring->maxNOfSamples;
    reqStruct->lastSampleID=reqMonitoring->lastSampleID;
    reqStruct->loopmode=reqMonitoring->loopMode;
    reqStruct->nofSamples=reqMonitoring->nOfSamples;
    reqStruct->status=reqMonitoring->status;
    reqStruct->requestUser=malloc(sizeof(char)*strlen(reqMonitoring->requestUser));
    strcpy(reqStruct->requestUser,reqMonitoring->requestUser);
    return reqStruct;
}
/**
 * This Function will check if the decodedCan message has a request already set for it. If so it will add/edit entries into the MIB
 */
void checkSamples(char* signalname,double value,int signals,char* timestamp){
    netsnmp_iterator *it;
    netsnmp_index index;
    oid index_oid[2];
    void* data;
    requestMonitoringStruct * reqStruct=(requestMonitoringStruct*)malloc(sizeof(requestMonitoringStruct));
    it=CONTAINER_ITERATOR(cb.container);
    if(NULL==it){
        exit;
    }
    /*InserÃ§oes no requestStatistics/requestMonitoring estao a falhar*/
    for(data=ITERATOR_FIRST(it);data;data=ITERATOR_NEXT(it)){
        requestMonitoringDataTable_context *reqMonitoring =data;
        index_oid[0] = reqMonitoring->requestID;
        index.oids = (oid *)&index_oid;
        index.len = 1;
        mapTypeTable_context* mapType;
        char unit[32];
        switch(reqMonitoring->status){
            case 0:
                /*Row is in Off mode, do nothing*/
                break;
            case 1:
                /*Row is in On mode, read data from CAN interface and add to tables*/
                mapType=findRow(reqMonitoring->requestMapID);
                if(mapType!=NULL){
                    if(strcmp(mapType->dataSource,signalname)==0){
                        samplesStruct* ss=(samplesStruct*)malloc(sizeof(samplesStruct));
                        int firstSampleTableEmptyID=firstSampleEntry();
                        int firstSampledValuesEntry=firstSampledEntry();
                        ss->sampleID=firstSampleTableEmptyID;
                        ss->previousSampleID=reqMonitoring->lastSampleID;
                        ss->requestSampleID=reqMonitoring->requestID;
                        ss->sampleFrequency=reqMonitoring->samplingFrequency;
                        //ss->sampleValueID=firstSampledValuesEntry;
                        ss->timestamp=malloc(sizeof(char)*64);
                        strcpy(ss->timestamp,timestamp);
                        int insertSamples=insertSamplesRow(ss);
                        free(ss);
                        if(insertSamples!=0)
                            printf("Samples insertion failed\n");
                        /*Add sampledStruct*/
                        /*
                        sampledStruct* svs=(sampledStruct*)malloc(sizeof(sampledStruct));
                        svs->nOfsampledValues=signals;
                        svs->mapTypeSamplesID=mapType->mapTypeID;
                        svs->relatedSampleValue=0;
                        svs->sampledValueID=firstSampledValuesEntry;
                        svs->sampleRecordedValue=value;
                        svs->sampleType=1;
                        int insertSampledValue=insertSampledValuesRow(svs);
                        free(svs);
                        if(insertSamples!=0)
                            printf("SampledValue insertion failed\n");
                        */
                        /*Update requestStatisticsDataTable*/
                        if(reqMonitoring->requestStatisticsID!=0){
                            requestStatisticsDataTable_context *statStruct=getStatisticsTable(reqMonitoring->requestStatisticsID);
                            statisticsStruct* sS=(statisticsStruct*)malloc(sizeof(statisticsStruct));
                            sS=convertStatStruct(statStruct,sS);
                            if(sS->maxValue<value)
                                sS->maxValue=value;
                            else
                                if(sS->minValue>value)
                                    sS->minValue=value;
                            double total=sS->avgValue*sS->nOfSamples;
                            total+=value;
                            sS->nOfSamples+=1;
                            sS->avgValue=total/sS->nOfSamples;
                            int inserted=insertStatisticsRow(sS);
                            if(inserted!=0){
                                printf("Statistics update failed\n");
                            }
                            free(sS);
                        }
                        /*Update requestMonitoringDataTable*/
                        reqStruct=tableToStruct(reqMonitoring,reqStruct);
                        reqStruct->lastSampleID=firstSampleTableEmptyID;
                        reqStruct->nofSamples+=1;
                        if(reqStruct->nofSamples==reqStruct->maxNofSamples){
                            reqStruct->status=0;
                            printf("Request %d finished\n",reqStruct->reqID);
                        }
                        int inserted=insertMonitoringRow(reqStruct);
                        requestMonitoringDataTable_create_row(&index,reqStruct);
                        /*TODO requestControl*/
                    }
                }
                break;
            case 2:
                /*Row is in SET mode, do nothing*/
                break;
            case 3:
                /*Row is in DELETE mode, do nothing*/
                break;
            default:
                printf("Undefined status\n");
                break;
        }
    }
    ITERATOR_RELEASE(it);
    free(reqStruct);
}
/**
 * This Function will compare requestMonitoringDataTable with requestControlDataTable, to identify if and when modifications are made (sets/deletes).
 */
void checkTables(){
    netsnmp_iterator *it;
    netsnmp_index index;
    oid index_oid[2];
    void* data;
    int delete;
    requestMonitoringStruct * reqStruct=(requestMonitoringStruct*)malloc(sizeof(requestMonitoringStruct));
    it=CONTAINER_ITERATOR(cb.container);
    if(NULL==it){
        exit;
    }
    for(data=ITERATOR_FIRST(it);data;data=ITERATOR_NEXT(it)){
        requestMonitoringDataTable_context *reqMonitoring =data;
        //requestID e requestControlID tÃªm de ser iguais
        requestControlDataTable_context *reqControl=getControlTableID(reqMonitoring->requestID);
        if(reqControl==NULL){
            /*TODO req->valuesTable e req->waitTime*/
            int insertControl=insertRowControl_Monitor(reqMonitoring);
            if(insertControl==1)
                exit;
            exit;
        }else{
            if(reqMonitoring->requestID==reqControl->requestControlID && reqMonitoring->status!=reqControl->statusControl){
                //If requestControlID matches requestID but their contents differ, this will update the row in requestControlDataTable
                int insertControl=insertRowControl_Monitor(reqMonitoring);
                if(insertControl!=0){
                    printf("Control update failed\n");
                    exit;
                }
            }
        }
        samplesTable_context* samplesTable;
        switch(reqMonitoring->status){
            case 0:
                /*Row is in Off mode, check if it can be switched to Delete mode*/
                break;
            case 1:
                /*Request is in On mode, do nothing*/
                break;
            case 2:
                /*Row is in set mode*/
                index_oid[0] = reqMonitoring->requestID;
                index.oids = (oid *)&index_oid;
                index.len = 1;
                reqMonitoring->status=1;
                if(reqMonitoring->requestStatisticsID!=0){
                    statisticsStruct *statStruct=(statisticsStruct*)malloc(sizeof(statisticsStruct));
                    statStruct->duration=malloc(sizeof(char)*reqMonitoring->durationTime_len);
                    statStruct->statID=reqMonitoring->requestStatisticsID;
                    strcpy(statStruct->duration,reqMonitoring->durationTime);
                    statStruct->nOfSamples=0;
                    statStruct->minValue=9999;
                    statStruct->maxValue=-999;
                    statStruct->avgValue=0;
                    int stat=insertStatisticsRow(statStruct);
                    free(statStruct);
                    if(stat!=0)
                        printf("Statistics insertion failed\n");
                }else
                    printf("No statistics\n");

                reqStruct=tableToStruct(reqMonitoring,reqStruct);
                requestMonitoringDataTable_create_row(&index,reqStruct);
                break;
            case 3:
                /*Row is in Delete mode, delete this row and all other rows related to this one*/
                /***********************Delete all samplesEntry***************************/
                reqStruct=tableToStruct(reqMonitoring,reqStruct);
                if(reqStruct->lastSampleID!=0){
                    samplesTable=getSampleEntry(reqStruct->lastSampleID);
                    while(samplesTable!=NULL){
                        int aux=samplesTable->sampleID;
                        
                        /*****************Delete all sampledEntry***********/
                        /*
                        sampledValuesTable_context* sampledTable=getSampledEntry(samplesTable->sampleValueID);
                        while(sampledTable!=NULL){
                            int aux2=sampledTable->sampledValueID;
                            sampledTable=getSampledEntry(sampledTable->relatedSampleValue);
                            delete=deleteSampledEntry(aux2);
                            if(delete!=0)
                                printf("SampledValuesEntry deletion failed ID:%d\n",aux2);
                        }
                        */
                        /***************************************************/
                        samplesTable=getSampleEntry(samplesTable->previousSampleID);
                        delete=deleteSamplesEntry(aux);
                        if(delete!=0)
                            printf("SampleEntry deletion Failed ID:%d\n",aux);
                    }
                }
                /*************************************************************************/
                /*Delete requestStatisticsDataEntry*/
                delete=deleteStatisticsEntry(reqStruct->statisticsRequestID);
                if(delete==1)
                    printf("Deletion of requestStatisticsDataEntry failed\n");
                else if(delete==2)
                    printf("RequestStatisticsDataEntry not found\n");
                /*Delete requestControlDataEntry*/
                delete=deleteControlEntry(reqStruct->reqID);
                if(delete==1)
                    printf("Deletion of requestControlDataEntry failed\n");
                else if(delete==2)
                    printf("RequestControlDataEntry not found\n");
                /*Delete requestMonitoringDataEntry*/
                delete=deleteRequestEntry(reqStruct);
                if(delete==1)
                    printf("Deletion of requestMonitoringDataEntry failed\n");
                else if(delete==2)
                    printf("RequestMonitoringDataEntry not found\n");

                break;
            default:
                printf("Undefined status\n");
                break;
        }
    }
    
    ITERATOR_RELEASE(it);
    free(reqStruct);
}


#ifdef requestMonitoringDataTable_CUSTOM_SORT
/************************************************************
 * keep binary tree to find context by name
 */
static int requestMonitoringDataTable_cmp(const void *lhs, const void *rhs);

/************************************************************
 * compare two context pointers here. Return -1 if lhs < rhs,
 * 0 if lhs == rhs, and 1 if lhs > rhs.
 */
static int
requestMonitoringDataTable_cmp(const void *lhs, const void *rhs)
{
    requestMonitoringDataTable_context *context_l =
        (requestMonitoringDataTable_context *)lhs;
    requestMonitoringDataTable_context *context_r =
        (requestMonitoringDataTable_context *)rhs;

    /*
     * check primary key, then secondary. Add your own code if
     * there are more than 2 keys
     */
    int rc;

    /*
     * TODO: implement compare. Remove this ifdef code and
     * add your own code here.
     */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR,
             "requestMonitoringDataTable_compare not implemented! Container order undefined\n");
    return 0;
#endif

    /*
     * EXAMPLE (assuming you want to sort on a name):
     *   
     * rc = strcmp( context_l->xxName, context_r->xxName );
     *
     * if(rc)
     *   return rc;
     *
     * TODO: fix secondary keys (or delete if there are none)
     *
     * if(context_l->yy < context_r->yy) 
     *   return -1;
     *
     * return (context_l->yy == context_r->yy) ? 0 : 1;
     */
}

/************************************************************
 * search tree
 */
/** TODO: set additional indexes as parameters */
requestMonitoringDataTable_context *
requestMonitoringDataTable_get(const char *name, int len)
{
    requestMonitoringDataTable_context tmp;

    /** we should have a custom container */
    netsnmp_assert(cb.container->next != NULL);

    /*
     * TODO: implement compare. Remove this ifdef code and
     * add your own code here.
     */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR, "requestMonitoringDataTable_get not implemented!\n");
    return NULL;
#endif

    /*
     * EXAMPLE:
     *
     * if(len > sizeof(tmp.xxName))
     *   return NULL;
     *
     * strncpy( tmp.xxName, name, sizeof(tmp.xxName) );
     * tmp.xxName_len = len;
     *
     * return CONTAINER_FIND(cb.container->next, &tmp);
     */
}
#endif
/************************************************************
 * Initializes the requestMonitoringDataTable module
 */
void init_requestMonitoringDataTable(void)
{
    requestMonitoringDataTable_context *ctx;
    netsnmp_index index;
    oid index_oid[2];
    initialize_table_requestMonitoringDataTable();

    requestMonitoringStruct *req = (requestMonitoringStruct *)malloc(sizeof(requestMonitoringStruct));
    req->reqID = 0;
    /*1894 atÃ© 1901*/
    req->requestMapID = 1898;
    req->statisticsRequestID = 1;
    req->savingMode = 0;
    req->sampleFreq = 10;
    req->maxDelay = -10;
    req->startTime = "00:00:00";
    req->endTime = "01:00:00";
    req->durationTime = "01:00:00";
    req->expireTime = "02:00:00";
    req->maxNofSamples = 10;
    req->lastSampleID = 0;
    req->loopmode = 1;
    req->nofSamples = 0;
    req->status = 2;
    req->requestUser="Utilizador teste";
    index_oid[0] = 0;
    index.oids = (oid *)&index_oid;
    index.len = 1;
    ctx = NULL;
    /* Search for it first. */
    ctx = CONTAINER_FIND(cb.container, &index);
    if (!ctx)
    {
        // No dice. We add the new row
        ctx = requestMonitoringDataTable_create_row(&index, req);
        CONTAINER_INSERT(cb.container, ctx);
    }
    free(req);
}

/**
 * the *_extract_index routine
 *
 * This routine is called when a set request is received for an index
 * that was not found in the table container. Here, we parse the oid
 * in the the individual index components and copy those indexes to the
 * context. Then we make sure the indexes for the new row are valid.
 */
int requestMonitoringDataTable_extract_index(requestMonitoringDataTable_context *ctx, netsnmp_index *hdr)
{
    /*
     * temporary local storage for extracting oid index
     *
     * extract index uses varbinds (netsnmp_variable_list) to parse
     * the index OID into the individual components for each index part.
     */
    netsnmp_variable_list var_requestID;
    int err;

    /*
     * copy index, if provided
     */
    if (hdr)
    {
        netsnmp_assert(ctx->index.oids == NULL);
        if ((hdr->len > MAX_OID_LEN) ||
            snmp_clone_mem((void *)&ctx->index.oids, hdr->oids,
                           hdr->len * sizeof(oid)))
        {
            return -1;
        }
        ctx->index.len = hdr->len;
    }

    /*
     * initialize variable that will hold each component of the index.
     * If there are multiple indexes for the table, the variable_lists
     * need to be linked together, in order.
     */
    memset(&var_requestID, 0x00, sizeof(var_requestID));
    var_requestID.type = ASN_UNSIGNED; /* type hint for parse_oid_indexes */
                                       /** TODO: link this index to the next, or NULL for the last one */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR, "requestMonitoringDataTable_extract_index index list not implemented!\n");
    return 0;
#else
    var_requestID.next_variable = NULL;
#endif

    /*
     * parse the oid into the individual index components
     */
    err = parse_oid_indexes(hdr->oids, hdr->len, &var_requestID);
    if (err == SNMP_ERR_NOERROR)
    {
        /*
        * copy index components into the context structure
        */
        ctx->requestID = *var_requestID.val.integer;

        /*
            * TODO: check index for valid values. For EXAMPLE:
            *
              * if ( *var_requestID.val.integer != XXX ) {
          *    err = -1;
          * }
          */
    }

    /*
     * parsing may have allocated memory. free it.
     */
    snmp_reset_var_buffers(&var_requestID);

    return err;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int requestMonitoringDataTable_can_delete(requestMonitoringDataTable_context *undo_ctx,
                                          requestMonitoringDataTable_context *row_ctx,
                                          netsnmp_request_group *rg)
{

    /*
     * TODO: check for other deletion requirements here
     */
    return 1;
}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index *requestMonitoringDataTable_delete_row(requestMonitoringDataTable_context *ctx)
{
    /* netsnmp_mutex_destroy(ctx->lock); */
    /*
    if (ctx->index.oids)
        free(ctx->index.oids);
    */
    free(ctx->data);

    /*
     * release header
     */
    free(ctx);

    return NULL;
}

/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void requestMonitoringDataTable_set_reserve1(netsnmp_request_group *rg)
{
    requestMonitoringDataTable_context *row_ctx =
        (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx =
        (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;
    int rc;

    /*
     * TODO: loop through columns, check syntax and lengths. For
     * columns which have no dependencies, you could also move
     * the value/range checking here to attempt to catch error
     * cases as early as possible.
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            
            break;

        case COLUMN_REQUESTCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            
            break;
        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_int(var);
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_int(var);
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->startTime));
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->endTime));
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->durationTime));
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->expireTime));
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_int(var);
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_int(var);
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->requestUser));
            break;
        default: /** We shouldn't get here */
            rc = SNMP_ERR_GENERR;
            snmp_log(LOG_ERR, "unknown column in "
                              "requestMonitoringDataTable_set_reserve1\n");
        }

        if (rc)
            netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri, rc);
        rg->status = SNMP_MAX(rg->status, current->ri->status);
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

void requestMonitoringDataTable_set_reserve2(netsnmp_request_group *rg)
{
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;
    netsnmp_variable_list *var;
    int rc;

    rg->rg_void = rg->list->ri;

    /*
     * TODO: loop through columns, check for valid
     * values and any range constraints.
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        case COLUMN_REQUESTCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        default:               /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }

        if (rc)
            netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri, rc);
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void requestMonitoringDataTable_set_action(netsnmp_request_group *rg)
{
    netsnmp_variable_list *var;
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    /*
     * TODO: loop through columns, copy varbind values
     * to context structure for the row.
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->requestID = *var->val.integer;
            break;
        case COLUMN_REQUESTCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->requestControlID = *var->val.integer;
            break;
        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->requestMapID = *var->val.integer;
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->requestStatisticsID = *var->val.integer;
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            row_ctx->savingMode = *var->val.integer;
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->samplingFrequency = *var->val.integer;
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            row_ctx->maxDelay = *var->val.integer;
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->startTime, var->val.string, var->val_len);
            row_ctx->startTime_len = var->val_len;
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->endTime, var->val.string, var->val_len);
            row_ctx->endTime_len = var->val_len;
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->durationTime, var->val.string, var->val_len);
            row_ctx->durationTime_len = var->val_len;
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->expireTime, var->val.string, var->val_len);
            row_ctx->expireTime_len = var->val_len;
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->maxNOfSamples = *var->val.integer;
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->lastSampleID = *var->val.integer;
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            row_ctx->loopMode = *var->val.integer;
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            row_ctx->status = *var->val.integer;
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            memcpy(row_ctx->requestUser, var->val.string, var->val_len);
            row_ctx->requestUser_len = var->val_len;
            break;
        default:               /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
    /*
     * TODO: if you have dependencies on other tables, this would be
     * a good place to check those, too.
     */
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void requestMonitoringDataTable_set_commit(netsnmp_request_group *rg)
{
    netsnmp_variable_list *var;
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;
        case COLUMN_REQUESTCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;
        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            break;
        default:               /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void requestMonitoringDataTable_set_free(netsnmp_request_group *rg)
{
    netsnmp_variable_list *var;
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            break;
        default: /** We shouldn't get here */
            break;
            /** should have been logged in reserve1 */
        }
    }
}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void requestMonitoringDataTable_set_undo(netsnmp_request_group *rg)
{
    netsnmp_variable_list *var;
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            break;

        default:               /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}
requestMonitoringDataTable_context *requestMonitoringDataTable_create_row_default(netsnmp_index *hdr)
{
    requestMonitoringDataTable_context *ctx = SNMP_MALLOC_TYPEDEF(requestMonitoringDataTable_context);
    if (!ctx)
        return NULL;
    if (requestMonitoringDataTable_extract_index(ctx, hdr))
    {
        free(ctx->index.oids);
        free(ctx);
        return NULL;
    }
    ctx->status=2;
    ctx->samplingFrequency=0;
    ctx->maxDelay=0;
    ctx->lastSampleID=0;
    ctx->nOfSamples=0;
    ctx->startTime_len=0;
    ctx->endTime_len=0;
    ctx->expireTime_len=0;
    ctx->durationTime_len=0;
    return ctx;
}
/************************************************************
 *
 * Initialize the requestMonitoringDataTable table by defining its contents and how it's structured
 */
void initialize_table_requestMonitoringDataTable(void)
{
    netsnmp_table_registration_info *table_info;

    if (my_handler)
    {
        snmp_log(LOG_ERR, "initialize_table_requestMonitoringDataTable_handler called again\n");
        return;
    }

    memset(&cb, 0x00, sizeof(cb));

    /** create the table structure itself */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

    my_handler = netsnmp_create_handler_registration("requestMonitoringDataTable",
                                                     netsnmp_table_array_helper_handler,
                                                     requestMonitoringDataTable_oid,
                                                     requestMonitoringDataTable_oid_len,
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info)
    {
        snmp_log(LOG_ERR, "malloc failed in "
                          "initialize_table_requestMonitoringDataTable_handler\n");
        return; /** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */
    /*
     * TODO: add any external indexes here.
     */

    /*
     * internal indexes
     */
    /** index: requestID */
    netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);

    table_info->min_column = requestMonitoringDataTable_COL_MIN;
    table_info->max_column = requestMonitoringDataTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
    cb.get_value = requestMonitoringDataTable_get_value;
    cb.container = netsnmp_container_find("requestMonitoringDataTable_primary:"
                                          "requestMonitoringDataTable:"
                                          "table_container");
#ifdef requestMonitoringDataTable_CUSTOM_SORT
    netsnmp_container_add_index(cb.container,
                                netsnmp_container_find("requestMonitoringDataTable_custom:"
                                                       "requestMonitoringDataTable:"
                                                       "table_container"));
    cb.container->next->compare = requestMonitoringDataTable_cmp;
#endif
    cb.can_set = 1;
    cb.duplicate_row = (UserRowMethod *)requestMonitoringDataTable_duplicate_row;
    cb.delete_row = (UserRowMethod *)requestMonitoringDataTable_delete_row;
    cb.row_copy = (Netsnmp_User_Row_Operation *)requestMonitoringDataTable_row_copy;
    cb.can_delete = (Netsnmp_User_Row_Action *)requestMonitoringDataTable_can_delete;
    cb.create_row=(UserRowMethod *)requestMonitoringDataTable_create_row_default;
    cb.set_reserve1 = requestMonitoringDataTable_set_reserve1;
    cb.set_reserve2 = requestMonitoringDataTable_set_reserve2;
    cb.set_action = requestMonitoringDataTable_set_action;
    cb.set_commit = requestMonitoringDataTable_set_commit;
    cb.set_free = requestMonitoringDataTable_set_free;
    cb.set_undo = requestMonitoringDataTable_set_undo;
    DEBUGMSGTL(("initialize_table_requestMonitoringDataTable",
                "Registering table requestMonitoringDataTable "
                "as a table array\n"));
    netsnmp_table_container_register(my_handler, table_info, &cb,
                                     cb.container, 1);
    
}

/************************************************************
 * requestMonitoringDataTable_get_value
 *
 * This routine is called for get requests to copy the data
 * from the context to the varbind for the request. If the
 * context has been properly maintained, you don't need to
 * change in code in this fuction.
 */
int requestMonitoringDataTable_get_value(
    netsnmp_request_info *request,
    netsnmp_index *item,
    netsnmp_table_request_info *table_info)
{
    netsnmp_variable_list *var = request->requestvb;
    requestMonitoringDataTable_context *context = (requestMonitoringDataTable_context *)item;
    switch (table_info->colnum)
    {

    case COLUMN_REQUESTID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->requestID,
                                 sizeof(context->requestID));
        break;
    case COLUMN_REQUESTCONTROLID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->requestControlID,
                                 sizeof(context->requestControlID));
        break;
    case COLUMN_REQUESTMAPID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->requestMapID,
                                 sizeof(context->requestMapID));
        break;

    case COLUMN_REQUESTSTATISTICSID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->requestStatisticsID,
                                 sizeof(context->requestStatisticsID));
        break;

    case COLUMN_SAVINGMODE:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->savingMode,
                                 sizeof(context->savingMode));
        break;

    case COLUMN_SAMPLINGFREQUENCY:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->samplingFrequency,
                                 sizeof(context->samplingFrequency));
        break;

    case COLUMN_MAXDELAY:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->maxDelay,
                                 sizeof(context->maxDelay));
        break;

    case COLUMN_STARTTIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->startTime,
                                 context->startTime_len);
        break;

    case COLUMN_ENDTIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->endTime,
                                 context->endTime_len);
        break;

    case COLUMN_DURATIONTIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->durationTime,
                                 context->durationTime_len);
        break;

    case COLUMN_EXPIRETIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->expireTime,
                                 context->expireTime_len);
        break;

    case COLUMN_MAXNOFSAMPLES:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->maxNOfSamples,
                                 sizeof(context->maxNOfSamples));
        break;

    case COLUMN_LASTSAMPLEID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->lastSampleID,
                                 sizeof(context->lastSampleID));
        break;

    case COLUMN_LOOPMODE:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->loopMode,
                                 sizeof(context->loopMode));
        break;

    case COLUMN_NOFSAMPLES:
        /** COUNTER = ASN_COUNTER */
        snmp_set_var_typed_value(var, ASN_COUNTER,
                                 (char *)&context->nOfSamples,
                                 sizeof(context->nOfSamples));
        break;

    case COLUMN_STATUS:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->status,
                                 sizeof(context->status));
        break;

    case COLUMN_REQUESTUSER:
        /** OCTET STRING = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->requestUser,
                                 context->requestUser_len);
        break;
    default: /** We shouldn't get here */
        snmp_log(LOG_ERR, "unknown column in "
                          "requestMonitoringDataTable_get_value\n");
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

/************************************************************
 * requestMonitoringDataTable_get_by_idx
 */
const requestMonitoringDataTable_context *
requestMonitoringDataTable_get_by_idx(netsnmp_index *hdr)
{
    return (const requestMonitoringDataTable_context *)
        CONTAINER_FIND(cb.container, hdr);
}
/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated requestMonitoringDataTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
requestMonitoringDataTable_context *requestMonitoringDataTable_create_row(netsnmp_index *hdr, requestMonitoringStruct *req)
{
    requestMonitoringDataTable_context *ctx = SNMP_MALLOC_TYPEDEF(requestMonitoringDataTable_context);
    if (!ctx)
        return NULL;
    if (requestMonitoringDataTable_extract_index(ctx, hdr))
    {
        free(ctx->index.oids);
        free(ctx);
        return NULL;
    }
    ctx->index.oids = ctx->oid_buf;
    ctx->oid_buf[0] = req->reqID;
    ctx->index.len = 1;
    ctx->requestID = (long unsigned int)req->reqID;
    ctx->requestControlID= (long unsigned int) req->requestControlID;
    ctx->requestMapID = (long unsigned int)req->requestMapID;
    ctx->requestStatisticsID = (long unsigned int)req->statisticsRequestID;
    ctx->savingMode = req->savingMode;
    ctx->samplingFrequency = req->sampleFreq;
    ctx->maxDelay = req->maxDelay;
    strcpy(ctx->startTime, req->startTime);
    ctx->startTime_len = strlen(req->startTime);
    strcpy(ctx->endTime, req->endTime);
    ctx->endTime_len = strlen(req->endTime);
    strcpy(ctx->durationTime, req->durationTime);
    ctx->durationTime_len = strlen(req->durationTime);
    strcpy(ctx->expireTime, req->expireTime);
    ctx->expireTime_len = strlen(req->expireTime);
    ctx->maxNOfSamples = (long unsigned int)req->maxNofSamples;
    ctx->lastSampleID = (long unsigned int)req->lastSampleID;
    ctx->loopMode = req->loopmode;
    ctx->nOfSamples = req->nofSamples;
    ctx->status = req->status;
    strcpy(ctx->requestUser,req->requestUser);
    ctx->requestUser_len=strlen(req->requestUser);
    return ctx;
}
/************************************************************
 * the *_duplicate row routine
 */
requestMonitoringDataTable_context *
requestMonitoringDataTable_duplicate_row(requestMonitoringDataTable_context *row_ctx)
{
    requestMonitoringDataTable_context *dup;

    if (!row_ctx)
        return NULL;

    dup = SNMP_MALLOC_TYPEDEF(requestMonitoringDataTable_context);
    if (!dup)
        return NULL;

    if (requestMonitoringDataTable_row_copy(dup, row_ctx))
    {
        free(dup);
        dup = NULL;
    }

    return dup;
}
/************************************************************
 * the *_row_copy routine
 */
int requestMonitoringDataTable_row_copy(requestMonitoringDataTable_context *dst, requestMonitoringDataTable_context *src)
{
    if (!dst || !src)
        return 1;

    /*
     * copy index, if provided
     */
    if (dst->index.oids)
        free(dst->index.oids);
    if (snmp_clone_mem((void *)&dst->index.oids, src->index.oids,
                       src->index.len * sizeof(oid)))
    {
        dst->index.oids = NULL;
        return 1;
    }
    dst->index.len = src->index.len;

    /*
     * copy components into the context structure
     */
    dst->requestID = src->requestID;
    dst->requestControlID=src->requestControlID;
    dst->requestMapID = src->requestMapID;
    dst->requestStatisticsID = src->requestStatisticsID;
    dst->savingMode = src->savingMode;
    dst->samplingFrequency = src->samplingFrequency;
    dst->maxDelay = src->maxDelay;
    memcpy(dst->startTime, src->startTime, src->startTime_len);
    dst->startTime_len = src->startTime_len;
    memcpy(dst->endTime, src->endTime, src->endTime_len);
    dst->endTime_len = src->endTime_len;
    memcpy(dst->durationTime, src->durationTime, src->durationTime_len);
    dst->durationTime_len = src->durationTime_len;
    memcpy(dst->expireTime, src->expireTime, src->expireTime_len);
    dst->expireTime_len = src->expireTime_len;
    dst->maxNOfSamples = src->maxNOfSamples;
    dst->lastSampleID = src->lastSampleID;
    dst->loopMode = src->loopMode;
    dst->nOfSamples = src->nOfSamples;
    dst->status = src->status;
    memcpy(dst->requestUser, src->requestUser, src->requestUser_len);
    dst->requestUser_len = src->requestUser_len;
    return 0;
}