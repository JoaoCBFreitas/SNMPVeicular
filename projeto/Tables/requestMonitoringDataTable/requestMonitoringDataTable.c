/*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.array-user.conf
 *
 *
 * For help understanding NET-SNMP in general, please check the 
 *     documentation and FAQ at:
 *
 *     http://www.net-snmp.org/
 *
 *
 * For help understanding this code, the agent and how it processes
 *     requests, please check the following references.
 *
 *     http://www.net-snmp.org/tutorial-5/
 *
 *
 * You can also join the #net-snmp channel on irc.freenode.net
 *     and ask for help there.
 *
 *
 * And if all else fails, send a detailed message to the developers
 *     describing the problem you are having to:
 *
 *    net-snmp-coders@lists.sourceforge.net
 *
 *
 * Yes, there is lots of code here that you might not use. But it is much
 * easier to remove code than to add it!
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>

#include "requestMonitoringDataTable.h"

static netsnmp_handler_registration *my_handler = NULL;
static netsnmp_table_array_callbacks cb;

const oid requestMonitoringDataTable_oid[] = {requestMonitoringDataTable_TABLE_OID};
const size_t requestMonitoringDataTable_oid_len = OID_LENGTH(requestMonitoringDataTable_oid);
/*This function will return the requestMonitoringDataEntry of the given ID*/
void *getMonitoringEntry(long unsigned int id)
{
    netsnmp_iterator *it;
    void *data;
    it = CONTAINER_ITERATOR(cb.container);
    int res = 1;
    if (NULL == it)
    {
        return NULL;
    }
    for (data = ITERATOR_FIRST(it); data; data = ITERATOR_NEXT(it))
    {
        requestMonitoringDataTable_context *req = data;
        if (req->requestID == id)
        {
            res = 0;
            break;
        }
    }
    ITERATOR_RELEASE(it);
    if (res == 1)
        return NULL;
    return data;
}
/*This function will return the next empty ID of requestMonitoringDataTable*/
int firstMonitoringEntry()
{
    netsnmp_iterator *it;
    void *data;
    it = CONTAINER_ITERATOR(cb.container);
    int res = 0;
    if (NULL == it)
    {
        return res;
    }
    for (data = ITERATOR_FIRST(it); data; data = ITERATOR_NEXT(it))
    {
        requestMonitoringDataTable_context *req = data;
        if (req != NULL)
            res = req->requestID + 1;
    }
    ITERATOR_RELEASE(it);
    return res;
}
/*This function will check if there's any request on a certain object whose savingMode is "permanent"
 0=Permanent requests found
 1=No permanent requests found
*/
int checkPermanentRequests(long unsigned int requestControlID, long unsigned int requestID)
{
    netsnmp_iterator *it;
    void *data;
    it = CONTAINER_ITERATOR(cb.container);
    if (NULL == it)
        exit;
    int res = 1;
    requestMonitoringDataTable_context *aux = (requestMonitoringDataTable_context *)malloc(sizeof(requestMonitoringDataTable_context));
    for (data = ITERATOR_FIRST(it); data; data = ITERATOR_NEXT(it))
    {
        requestMonitoringDataTable_context *req = data;
        if (req->requestID != requestID && req->requestControlID == requestControlID)
        {
            if (req->savingMode == 0)
            {
                res = 0;
                break;
            }
        }
    }
    ITERATOR_RELEASE(it);
    return res;
}
/*This function will check if there's any request on a certain object whose status is "set", "ready" or "on"
 0=Active requests found
 1=No active requests found
*/
int checkActiveRequests(long unsigned int requestControlID, long unsigned int requestID)
{
    netsnmp_iterator *it;
    void *data;
    it = CONTAINER_ITERATOR(cb.container);
    if (NULL == it)
        exit;
    int res = 1;
    requestMonitoringDataTable_context *aux = (requestMonitoringDataTable_context *)malloc(sizeof(requestMonitoringDataTable_context));
    for (data = ITERATOR_FIRST(it); data; data = ITERATOR_NEXT(it))
    {
        requestMonitoringDataTable_context *req = data;
        if (req->requestID != requestID && req->requestControlID == requestControlID)
        {
            if (req->status == 1 || req->status == 2 || req->status == 4)
            {
                res = 0;
                break;
            }
        }
    }
    ITERATOR_RELEASE(it);
    return res;
}
/*This function will perform a deepcopy of requestMonitoringDataTable_context*/
requestMonitoringDataTable_context *deepCopyReqMonitoring(requestMonitoringDataTable_context *dst, requestMonitoringDataTable_context *src)
{
    dst->requestID = src->requestID;
    dst->requestControlID = src->requestControlID;
    dst->requestMapID = src->requestMapID;
    dst->requestStatisticsID = src->requestStatisticsID;
    dst->savingMode = src->savingMode;
    dst->samplingFrequency = src->samplingFrequency;
    dst->maxDelay = src->maxDelay;
    strcpy(dst->startTime, src->startTime);
    dst->startTime_len = src->startTime_len;
    strcpy(dst->endTime, src->endTime);
    dst->endTime_len = src->endTime_len;
    strcpy(dst->waitTime, src->waitTime);
    dst->waitTime_len = src->waitTime_len;
    strcpy(dst->durationTime, src->durationTime);
    dst->durationTime_len = src->durationTime_len;
    strcpy(dst->expireTime, src->expireTime);
    dst->expireTime_len = src->expireTime_len;
    dst->lastSampleID = src->lastSampleID;
    dst->nOfSamples = src->nOfSamples;
    dst->maxNOfSamples = src->maxNOfSamples;
    dst->loopMode = src->loopMode;
    dst->status = src->status;
    strcpy(dst->requestUser, src->requestUser);
    dst->requestUser_len = src->requestUser_len;
    return dst;
}

/*This function will check if an user has already made a request on an object*/
int checkUserExists(unsigned long id, char *user, unsigned long requestMapID)
{
    netsnmp_iterator *it;
    void *data;
    it = CONTAINER_ITERATOR(cb.container);
    int res = 0;
    if (NULL == it)
    {
        return res;
    }
    for (data = ITERATOR_FIRST(it); data; data = ITERATOR_NEXT(it))
    {
        requestMonitoringDataTable_context *req = data;
        if (req->requestID != id)
            if (req->requestMapID == requestMapID)
            {
                if (strcmp(req->requestUser, user) == 0)
                {
                    res = 1;
                    break;
                }
            }
    }
    ITERATOR_RELEASE(it);
    return res;
}
/*This function will check what can be done to requestControlEntry and samplesEntry that are related to a requestMonitoringEntry that is being deleted.
  There are 3 possible outcomes from this function
  1º There's only one request-> delete everything -- returns -1
  2º There's at least one "active" request on this object -> find lowest startTime -- returns id
  3º There's another request with same startTime as this one-> do nothing -- returns -2*/
int requestTimeChecker(char *startTime, long unsigned int requestMapID, long unsigned int reqID)
{
    int res = -2;
    int found = 0;
    int f = 0;
    void *data;
    netsnmp_iterator *it;
    /*tmLowest will be used to store the 2nd lowest startTime (if it exists)*/
    struct tm *tmLowest = (struct tm *)malloc(sizeof(struct tm *));
    /*aux will be used to store the startTime of the request that is currently being checked*/
    struct tm *aux = (struct tm *)malloc(sizeof(struct tm *));
    it = CONTAINER_ITERATOR(cb.container);
    if (NULL == it)
    {
        exit;
    }
    for (data = ITERATOR_FIRST(it); data; data = ITERATOR_NEXT(it))
    {
        requestMonitoringDataTable_context *reqMonitoring = data;
        if (reqMonitoring->requestID != reqID && reqMonitoring->requestMapID == requestMapID)
        {
            /*Compare times*/
            if (strcmp(reqMonitoring->startTime, startTime) == 0)
            {
                /*There's another request on the same object with same startTime*/
                f = 1;
                break;
            }
            else
            {
                if (found == 0)
                {
                    tmLowest = convertTime(tmLowest, reqMonitoring->startTime);
                    res = reqMonitoring->requestID;
                    found = 1;
                }
                else
                {
                    aux = convertTime(aux, reqMonitoring->startTime);
                    if (compareTimeStamp(aux, tmLowest) == 1)
                    {
                        tmLowest = deepCopyTM(aux, tmLowest);
                        res = reqMonitoring->requestID;
                    }
                }
            }
        }
    }
    /*tmLowest will be NULL if there's only one request on the object*/
    if (found == 0 && f == 0)
        res = -1;
    ITERATOR_RELEASE(it);
    free(aux);
    free(tmLowest);
    return res;
}
/*This function will delete an entry from requestMonitoringDataTable*/
int deleteRequestEntry(requestMonitoringStruct *req)
{
    requestMonitoringDataTable_context *ctx;
    netsnmp_index index;
    oid index_oid[2];
    index_oid[0] = req->reqID;
    index.oids = (oid *)&index_oid;
    index.len = 1;
    ctx = NULL;
    /* Search for it first. */
    ctx = CONTAINER_FIND(cb.container, &index);
    if (ctx)
    {
        CONTAINER_REMOVE(cb.container, &index);
        requestMonitoringDataTable_delete_row(ctx);
    }
    else
    {
        return 2;
    }
    ctx = CONTAINER_FIND(cb.container, &index);
    if (ctx)
        return 1;
    else
        return 0;
}
/************************************************************
 * This function inserts a requestMonitoringStruct into the requestMonitoringDataTable
 */
int insertMonitoringRow(requestMonitoringStruct *req)
{
    requestMonitoringDataTable_context *ctx;
    netsnmp_index index;
    oid index_oid[2];
    index_oid[0] = req->reqID;
    index.oids = (oid *)&index_oid;
    index.len = 1;
    ctx = NULL;
    /* Search for it first. */
    ctx = CONTAINER_FIND(cb.container, &index);
    /*Delete previous entry if it already exists*/
    if (ctx)
    {
        CONTAINER_REMOVE(cb.container, &index);
        requestMonitoringDataTable_delete_row(ctx);
        ctx = requestMonitoringDataTable_create_row(&index, req);
        CONTAINER_INSERT(cb.container, ctx);
        return 0;
    }
    else
    {
        ctx = requestMonitoringDataTable_create_row(&index, req);
        CONTAINER_INSERT(cb.container, ctx);
        return 0;
    }
    return 1;
}
/*This function will add a row to requestControlDataTable based on the contents of requestMonitoringDataTable*/
int insertRowControl_Monitor(requestMonitoringDataTable_context *reqMonitoring)
{
    requestStruct *req = (requestStruct *)malloc(sizeof(requestStruct));
    req->reqID = reqMonitoring->requestControlID;
    req->requestControlMapID = reqMonitoring->requestMapID;
    req->settingMode = reqMonitoring->savingMode;
    req->commitTime = malloc(sizeof(char) * reqMonitoring->startTime_len + 1);
    strcpy(req->commitTime, reqMonitoring->startTime);
    req->endTime = malloc(sizeof(char) * reqMonitoring->endTime_len + 1);
    strcpy(req->endTime, reqMonitoring->endTime);
    req->duration = malloc(sizeof(char) * reqMonitoring->durationTime_len + 1);
    strcpy(req->duration, reqMonitoring->durationTime);
    req->expireTime = malloc(sizeof(char) * reqMonitoring->expireTime_len + 1);
    strcpy(req->expireTime, reqMonitoring->expireTime);
    if (reqMonitoring->status == 1 || reqMonitoring->status == 2 || reqMonitoring->status == 4)
        req->status = 1;
    if (reqMonitoring->status == 0)
        req->status = 0;
    req->valuesTable = 0;
    int insert = insertControlRow(req);
    free(req);
    return insert;
}
/*This function will convert a requestMonitoringDataTable_context to requestMonitoringStruct*/
requestMonitoringStruct *tableToStruct(requestMonitoringDataTable_context *reqMonitoring, requestMonitoringStruct *reqStruct)
{
    reqStruct->reqID = reqMonitoring->requestID;
    reqStruct->requestControlID = reqMonitoring->requestControlID;
    reqStruct->requestMapID = reqMonitoring->requestMapID;
    reqStruct->statisticsRequestID = reqMonitoring->requestStatisticsID;
    reqStruct->savingMode = reqMonitoring->savingMode;
    reqStruct->sampleFreq = reqMonitoring->samplingFrequency;
    reqStruct->maxDelay = reqMonitoring->maxDelay;
    reqStruct->startTime = malloc(sizeof(char) * reqMonitoring->startTime_len);
    reqStruct->endTime = malloc(sizeof(char) * reqMonitoring->endTime_len);
    reqStruct->waitTime = malloc(sizeof(char) * reqMonitoring->waitTime_len);
    reqStruct->durationTime = malloc(sizeof(char) * reqMonitoring->durationTime_len);
    reqStruct->expireTime = malloc(sizeof(char) * reqMonitoring->expireTime_len);
    strcpy(reqStruct->startTime, reqMonitoring->startTime);
    strcpy(reqStruct->endTime, reqMonitoring->endTime);
    strcpy(reqStruct->waitTime, reqMonitoring->waitTime);
    strcpy(reqStruct->durationTime, reqMonitoring->durationTime);
    strcpy(reqStruct->expireTime, reqMonitoring->expireTime);
    reqStruct->maxNofSamples = reqMonitoring->maxNOfSamples;
    reqStruct->lastSampleID = reqMonitoring->lastSampleID;
    reqStruct->loopmode = reqMonitoring->loopMode;
    reqStruct->nofSamples = reqMonitoring->nOfSamples;
    reqStruct->status = reqMonitoring->status;
    reqStruct->requestUser = malloc(sizeof(char) * reqMonitoring->requestUser_len);
    strcpy(reqStruct->requestUser, reqMonitoring->requestUser);
    return reqStruct;
}
/**
 * This Function will check if the decodedCan message has a request already set for it. If so it will add/edit entries into the MIB
 */
void checkSamples(char *signalname, double value, int signals, char *timestamp, char *checksum)
{
    netsnmp_iterator *it;
    netsnmp_index index;
    oid index_oid[2];
    void *data;
    requestMonitoringStruct *reqStruct = (requestMonitoringStruct *)malloc(sizeof(requestMonitoringStruct));
    requestStruct *reqControlStruct = (requestStruct *)malloc(sizeof(requestStruct));
    it = CONTAINER_ITERATOR(cb.container);
    if (NULL == it)
    {
        exit;
    }
    for (data = ITERATOR_FIRST(it); data;)
    {
        /*data = ITERATOR_NEXT(it) is not in for loop setting because otherwise everytime a row is edited the iterator would be lost*/
        requestMonitoringDataTable_context *reqMonitoring = data;
        index_oid[0] = reqMonitoring->requestID;
        index.oids = (oid *)&index_oid;
        index.len = 1;
        mapTypeTable_context *mapType;
        char unit[32];
        if (reqMonitoring->status == 1)
        {
            /*Row is in On mode, read data from CAN interface and add to tables*/
            mapType = findRow(reqMonitoring->requestMapID);
            if (mapType != NULL)
            {
                if (strcmp(mapType->dataSource, signalname) == 0)
                {
                    int sampleExists = checkSampleChecksum(checksum, mapType->mapTypeID);
                    /*Update requestStatisticsDataTable */
                    if (reqMonitoring->requestStatisticsID != 0)
                    {
                        requestStatisticsDataTable_context *statStruct = getStatisticsTable(reqMonitoring->requestStatisticsID);
                        statisticsStruct *sS = (statisticsStruct *)malloc(sizeof(statisticsStruct));
                        sS = convertStatStruct(statStruct, sS);
                        if (sS->maxValue < value)
                            sS->maxValue = value;
                        if (sS->minValue > value)
                            sS->minValue = value;
                        double total = sS->avgValue * sS->nOfSamples;
                        total += value;
                        sS->nOfSamples += 1;
                        sS->avgValue = total / sS->nOfSamples;
                        int inserted = insertStatisticsRow(sS);
                        if (inserted != 0)
                        {
                            printf("Statistics update failed\n");
                        }
                        free(sS);
                    }
                    if (sampleExists != 0)
                    {
                        /*Update requestMonitoringDataTable*/
                        reqStruct = tableToStruct(reqMonitoring, reqStruct);
                        reqStruct->lastSampleID = sampleExists;
                        reqStruct->nofSamples += 1;
                        if (reqStruct->nofSamples >= reqStruct->maxNofSamples)
                        {
                            reqStruct->status = 0;
                            printf("Request %d finished\n", reqStruct->reqID);
                        }
                        data = ITERATOR_NEXT(it);
                        int inserted = insertMonitoringRow(reqStruct);
                    }
                    else
                    {
                        samplesStruct *ss = (samplesStruct *)malloc(sizeof(samplesStruct));
                        int firstSampleTableEmptyID = firstSampleEntry();
                        ss->sampleID = firstSampleTableEmptyID;
                        ss->requestSampleID = reqMonitoring->requestControlID;
                        ss->timestamp = malloc(sizeof(char) * 64);
                        strcpy(ss->timestamp, timestamp);
                        ss->sampleFrequency = reqMonitoring->samplingFrequency;
                        ss->previousSampleID = reqMonitoring->lastSampleID;
                        ss->sampleType = 1;
                        ss->sampleRecordedValue = value;
                        ss->mapTypeSamplesID = mapType->mapTypeID;
                        ss->sampleCheckSum = malloc(sizeof(char) * strlen(checksum));
                        strcpy(ss->sampleCheckSum, checksum);
                        int insertSamples = insertSamplesRow(ss);
                        free(ss);
                        if (insertSamples != 0)
                            printf("Samples insertion failed\n");
                        /*Update requestMonitoringDataTable*/
                        reqStruct = tableToStruct(reqMonitoring, reqStruct);
                        reqStruct->lastSampleID = firstSampleTableEmptyID;
                        reqStruct->nofSamples += 1;
                        if (reqStruct->nofSamples >= reqStruct->maxNofSamples)
                        {
                            reqStruct->status = 0;
                            printf("Request %d finished\n", reqStruct->reqID);
                        }
                        data = ITERATOR_NEXT(it);
                        int inserted = insertMonitoringRow(reqStruct);
                        /*Update requestControlDataTable*/
                        reqControlStruct = reqControlConvert(getControlTableID(reqStruct->requestControlID), reqControlStruct);
                        if (reqControlStruct->valuesTable != reqStruct->lastSampleID)
                        {
                            reqControlStruct->valuesTable = reqStruct->lastSampleID;
                            int insertedControl = insertControlRow(reqControlStruct);
                        }
                    }
                }
                else
                    data = ITERATOR_NEXT(it);
            }
            else
                data = ITERATOR_NEXT(it);
        }
        else
            data = ITERATOR_NEXT(it);
    }
    ITERATOR_RELEASE(it);
    free(reqStruct);
    free(reqControlStruct);
}
/**
 * This Function will activate, deactivate and delete requests on requestMonitoringDataTable.
 * It will also create auxiliary entrys on other requestControlDataTable and requestStatisticsDataTable.
 * When deleting a request entry, this function will delete all related entrys on other tables (samplesTable, requestControlDataTable and requestStatisticsDataTable). 
 * It won't delete entrys on samplesTable and requestControlDataTable that are related to more than one request.
 * Lastly it will also call for the function checkError, whose role is to manage errorTable.
 */
void checkTables()
{
    netsnmp_iterator *it;
    netsnmp_index index;
    oid index_oid[2];
    void *data;
    int delete;
    time_t t = time(NULL);
    struct tm *tm = localtime(&t);
    requestMonitoringStruct *reqStruct = (requestMonitoringStruct *)malloc(sizeof(requestMonitoringStruct));
    checkError();
    it = CONTAINER_ITERATOR(cb.container);
    if (NULL == it)
    {
        exit;
    }
    for (data = ITERATOR_FIRST(it); data; data = ITERATOR_NEXT(it))
    {
        requestMonitoringDataTable_context *reqMonitoring = data;
        requestControlDataTable_context *reqControl = getControlTableID(reqMonitoring->requestControlID);
        if (reqMonitoring->status == 2)
        {
            int f = 0;
            int insert = 0;
            int errorID = -1;
            time_t t = time(NULL);
            struct tm *tm = localtime(&t);
            char s[100];
            if (reqMonitoring->startTime_len == 0)
            {
                /*If the user set no start time, then start time will be current system time*/
                snprintf(s, 100, "%02d/%02d/%04d %02d:%02d:%02d", tm->tm_mday, tm->tm_mon + 1, tm->tm_year + 1900, tm->tm_hour, tm->tm_min, tm->tm_sec);
                strcpy(reqMonitoring->startTime, s);
                reqMonitoring->startTime_len = strlen(s);
            }
            else if (reqMonitoring->startTime_len == 8)
            {
                /*If startTime is set by the user, it will be set with Hours:Min:Sec*/
                snprintf(s, 100, "%02d/%02d/%04d ", tm->tm_mday, tm->tm_mon + 1, tm->tm_year + 1900);
                strcat(s, reqMonitoring->startTime);
                strcpy(reqMonitoring->startTime, s);
                reqMonitoring->startTime_len = strlen(s);
            }
            /*tmAux will be used to validate startTime by comparing it to current time*/
            struct tm *tmAux = (struct tm *)malloc(sizeof(struct tm));
            tmAux = convertTime(tmAux, reqMonitoring->startTime);
            if (validateTime(reqMonitoring->startTime + 11) != 0 || compareTimeStamp(tm, tmAux) == 2)
            {
                /*Invalid startTime,errorID=0*/
                errorID = 0;
                f = 1;
            }
            else if (validateTime(reqMonitoring->waitTime) != 0)
            {
                /*Invalid waitTime, errorID=1*/
                errorID = 1;
                f = 1;
            }
            else if (validateTime(reqMonitoring->durationTime) != 0)
            {
                /*Invalid durationTime, errorID=2*/
                errorID = 2;
                f = 1;
            }
            else if (validateTime(reqMonitoring->expireTime) != 0)
            {
                /*Invalid expireTime, errorID=3*/
                errorID = 3;
                f = 1;
            }
            else if (reqMonitoring->maxNOfSamples <= 0)
            {
                /*Invalid maxNOfSamples, errorID=4*/
                errorID = 4;
                f = 1;
            }
            else if (reqMonitoring->savingMode != 0 && reqMonitoring->savingMode != 1)
            {
                /*Invalid saving Mode, errorID=5*/
                errorID = 5;
                f = 1;
            }
            else if (checkUserExists(reqMonitoring->requestID, reqMonitoring->requestUser, reqMonitoring->requestMapID) != 0)
            {
                /*There's already a request on this object made by this user, errorID=6*/
                errorID = 6;
                f = 1;
            }
            else if (reqMonitoring->requestStatisticsID != 0 && reqMonitoring->requestStatisticsID != 1)
            {
                /*Invalid Statistics,errorID=7*/
                errorID = 7;
                f = 1;
            }
            else if (reqMonitoring->requestMapID < 0 || findRow(reqMonitoring->requestMapID) == NULL)
            {
                /*Invalid Sensor, errorID=8*/
                errorID = 8;
                f = 1;
            }
            else if (reqMonitoring->loopMode != 1 && reqMonitoring->loopMode != 2)
            {
                /*Invalid loop Mode,erroID=9*/
                errorID = 9;
                f = 1;
            }
            if (f == 1 && errorID >= 0)
            {
                insert = addError(reqMonitoring->requestUser, errorID);
                if (insert != 0)
                    printf("Error Insertion failed\n");
                reqMonitoring->status = 3;
            }
            reqMonitoring->status = 4;
            free(tmAux);
        }
        if (reqControl == NULL || reqControl->requestControlMapID != reqMonitoring->requestMapID)
        {
            /*check if there's already a requestControl for this object
                if not create new row*/
            int controlExists = checkControlExist(reqMonitoring->requestMapID);
            if (controlExists == -1)
            {
                int id = firstControlEntry();
                reqMonitoring->requestControlID = (unsigned long)id;
                int insertControl = insertRowControl_Monitor(reqMonitoring);
                reqControl = getControlTableID(reqMonitoring->requestID);
                if (insertControl == 1)
                {
                    printf("Control insertion failed\n");
                    exit;
                }
            }
        }
        else
        {
            if (reqMonitoring->status != 0 && reqControl->statusControl != 1)
            {
                /*If this requestMonitoring entry is either "set", "ready" or "on" 
                and the corresponding requestControlEntry is "inactive", change status of requestControlEntry to "active" */
                requestStruct *aux = (requestStruct *)malloc(sizeof(requestStruct));
                aux = reqControlConvert(reqControl, aux);
                aux->status = 1;
                int insertControl = insertControlRow(aux);
                reqControl = getControlTableID(reqMonitoring->requestControlID);
                if (insertControl != 0)
                {
                    printf("Control update failed\n");
                    exit;
                }
                free(aux);
            }
            if (reqMonitoring->status == 0 && reqControl->statusControl == 1)
            {
                /*If this requestMonitoring entry is "Off" check if there's any other request on this object whose status is either "set", "ready" or "on".
                If none are found change status of requestControlEntry to "inactive"*/
                int active = checkActiveRequests(reqMonitoring->requestControlID, reqMonitoring->requestID);
                if (active == 1)
                {
                    /*No active requestMonitoringEntry's found*/
                    requestStruct *aux = (requestStruct *)malloc(sizeof(requestStruct));
                    aux = reqControlConvert(reqControl, aux);
                    aux->status = 0;
                    int insertControl = insertControlRow(aux);
                    reqControl = getControlTableID(reqMonitoring->requestControlID);
                    if (insertControl != 0)
                    {
                        printf("Control update failed\n");
                        exit;
                    }
                    free(aux);
                }
            }
            if (reqMonitoring->savingMode == 0 && reqControl->settingMode == 1)
            {
                /*If requestMonitoringEntry is set to "permanent" while requestControl is in "volatile" mode, change settingMode to "permanent"*/
                requestStruct *aux = (requestStruct *)malloc(sizeof(requestStruct));
                aux = reqControlConvert(reqControl, aux);
                aux->settingMode = 0;
                int insertControl = insertControlRow(aux);
                reqControl = getControlTableID(reqMonitoring->requestControlID);
                if (insertControl != 0)
                {
                    printf("Control update failed\n");
                    exit;
                }
                free(aux);
            }
            if (reqMonitoring->savingMode == 1 && reqControl->settingMode == 0)
            {
                /*If reqMonitoringEntry is "volatile" while requestControl is "permanent", check if there's any other request on this object with "permanent" saving mode
                If there's none, change setting mode of requestControl to "volatile"*/
                int permanent = checkPermanentRequests(reqMonitoring->requestControlID, reqMonitoring->requestID);
                if (permanent == 1)
                {
                    /*No permanent requestMonitoringEntry's found*/
                    requestStruct *aux = (requestStruct *)malloc(sizeof(requestStruct));
                    aux = reqControlConvert(reqControl, aux);
                    aux->settingMode = 1;
                    int insertControl = insertControlRow(aux);
                    reqControl = getControlTableID(reqMonitoring->requestControlID);
                    if (insertControl != 0)
                    {
                        printf("Control update failed\n");
                        exit;
                    }
                    free(aux);
                }
            }
        }
        samplesTable_context *samplesTable;
        char *timestamp = malloc(sizeof(char) * reqMonitoring->endTime_len + 1);
        struct tm *tm2 = (struct tm *)malloc(sizeof(struct tm));
        char *hour = malloc(sizeof(char) * 3);
        char *min = malloc(sizeof(char) * 3);
        switch (reqMonitoring->status)
        {
        case 0:
            /*Row is in Off mode, compare current timestamp with endTime+expireTime*/
            strcpy(timestamp, reqMonitoring->endTime);
            tm2 = convertTime(tm2, timestamp);
            strncpy(hour, reqMonitoring->expireTime, 2);
            strncpy(min, reqMonitoring->expireTime + 3, 2);
            min[2] = '\0';
            hour[2] = '\0';
            tm2 = addToTime(tm2, atoi(hour), atoi(min));
            if (compareTimeStamp(tm, tm2) == 0 || compareTimeStamp(tm, tm2) == 2)
            {
                /*Expire time is reached, set row to delete*/
                reqStruct = tableToStruct(reqMonitoring, reqStruct);
                reqStruct->status = 3;
                insertMonitoringRow(reqStruct);
            }
            break;
        case 1:
            /*Request is in On mode, compare current timestamp with endTime*/
            strcpy(timestamp, reqMonitoring->endTime);
            tm2 = convertTime(tm2, timestamp);
            if (compareTimeStamp(tm, tm2) != 1)
            {
                /*Duration time is reached, set row to off*/
                reqStruct = tableToStruct(reqMonitoring, reqStruct);
                reqStruct->status = 0;
                insertMonitoringRow(reqStruct);
            }
            break;
        case 2:
            /*Row is in set mode, do nothing*/
            break;
        case 3:
            /*Row is in Delete mode, delete this row and all other rows uniquely related to this one*/
            /***********************Delete all samplesEntry***************************/
            reqStruct = tableToStruct(reqMonitoring, reqStruct);
            /*Compare startTime of the entry that is to be deleted with commitTime of requestControl
            If startTime is different from commitTime, do Nothing
            If startTime is equal to commitTime, check if there's another request with the same startTime and requestMap,
                if so do nothing, if not:
                                         update commitTime to the 2nd lowest of all requestMonitoringEntrys that point to that requestControlEntry
                                         delete every sample that predate the new commitTime*/
            if (strcmp(reqStruct->startTime, reqControl->commitTime) == 0)
            {
                /*Check for other requests with same startTime and same requestMapID*/
                int reqTime = requestTimeChecker(reqStruct->startTime, reqStruct->requestMapID, reqStruct->reqID);
                if (reqTime == -1)
                {
                    /*There's only one request, delete everything*/
                    delete = deleteControlEntry(reqStruct->requestControlID);
                    if (delete == 1)
                        printf("Deletion of requestControlDataEntry failed\n");
                    if (reqStruct->lastSampleID != 0)
                    {
                        samplesTable = getSampleEntry(reqStruct->lastSampleID);
                        while (samplesTable != NULL)
                        {
                            int aux = samplesTable->sampleID;
                            samplesTable = getSampleEntry(samplesTable->previousSampleID);
                            delete = deleteSamplesEntry(aux);
                            if (delete != 0)
                                printf("SampleEntry deletion Failed ID:%d\n", aux);
                        }
                    }
                }
                if (reqTime >= 0)
                {
                    /************Update requestControlEntry******************/
                    requestMonitoringDataTable_context *reqAux = getMonitoringEntry(reqTime);
                    if (reqAux != NULL)
                    {
                        requestStruct *aux = (requestStruct *)malloc(sizeof(requestStruct));
                        aux = reqControlConvert(reqControl, aux);
                        strcpy(aux->commitTime, reqAux->startTime);
                        strcpy(aux->duration, reqAux->durationTime);
                        strcpy(aux->endTime, reqAux->endTime);
                        strcpy(aux->expireTime, reqAux->expireTime);
                        int insertControl = insertControlRow(aux);
                        reqControl = getControlTableID(reqAux->requestControlID);
                        if (insertControl != 0)
                        {
                            printf("Control update failed\n");
                            exit;
                        }
                        free(aux);
                    }
                    else
                    {
                        printf("Failed to obtain requestMonitoringDataEntry\n");
                        exit;
                    }
                    /**************************************************/
                    /********************Delete Samples****************/
                    if (reqMonitoring->lastSampleID != 0)
                    {
                        samplesTable = getSampleEntry(reqMonitoring->lastSampleID);
                        struct tm *tmSample = (struct tm *)malloc(sizeof(struct tm));
                        struct tm *tmControl = (struct tm *)malloc(sizeof(struct tm));
                        tmControl = convertTime(tmControl, reqControl->commitTime);
                        tmSample = convertTime(tmSample, samplesTable->timeStamp);
                        /*Go through all samples until a sample that predates commitTime is found*/
                        while (samplesTable != NULL && compareTimeStamp(tmSample, tmControl) != 1)
                        {
                            samplesTable = getSampleEntry(samplesTable->previousSampleID);
                            tmSample = convertTime(tmSample, samplesTable->timeStamp);
                        }
                        /*Sample that predates commitTime is found, delete from this sample onwards*/
                        while (samplesTable != NULL)
                        {
                            int aux = samplesTable->sampleID;
                            samplesTable = getSampleEntry(samplesTable->previousSampleID);
                            delete = deleteSamplesEntry(aux);
                            if (delete != 0)
                                printf("SampleEntry deletion Failed ID:%d\n", aux);
                        }
                        sampleZero(reqStruct->lastSampleID);
                        free(tmSample);
                        free(tmControl);
                    }
                }
            }
            /*************************************************************************/
            /*Delete requestStatisticsDataEntry*/
            if (reqStruct->statisticsRequestID != 0)
            {
                delete = deleteStatisticsEntry(reqStruct->statisticsRequestID);
                if (delete == 1)
                    printf("Deletion of requestStatisticsDataEntry failed\n");
            }
            /*Delete requestMonitoringDataEntry*/
            delete = deleteRequestEntry(reqStruct);
            if (reqStruct->loopmode == 1)
            {
                /*This Entry has loopMode enabled, create new row*/
                reqStruct->nofSamples = 0;
                reqStruct->requestControlID = 0;
                reqStruct->reqID = firstMonitoringEntry();
                reqStruct->endTime = "";
                reqStruct->startTime = "";
                reqStruct->statisticsRequestID = 1;
                reqStruct->lastSampleID = 0;
                reqStruct->status = 2;
                insertMonitoringRow(reqStruct);
            }
            if (delete == 1)
                printf("Deletion of requestMonitoringDataEntry failed\n");
            else if (delete == 2)
                printf("RequestMonitoringDataEntry not found\n");

            break;
        case 4:
            /*Row is in ready mode, change status from ready to On when startTime+waitTime has passed*/
            if (reqMonitoring->endTime_len == 0)
            {
                /*If column EndTime is empty, it will be calculated by adding startTime+waitTime+durationTime*/
                strncpy(hour, reqMonitoring->waitTime, 2);
                strncpy(min, reqMonitoring->waitTime + 3, 2);
                min[2] = '\0';
                hour[2] = '\0';
                strcpy(timestamp, reqMonitoring->startTime);
                tm2 = convertTime(tm2, timestamp);
                tm2 = addToTime(tm2, atoi(hour), atoi(min));
                strncpy(hour, reqMonitoring->durationTime, 2);
                strncpy(min, reqMonitoring->durationTime + 3, 2);
                min[2] = '\0';
                hour[2] = '\0';
                tm2 = addToTime(tm2, atoi(hour), atoi(min));
                char s[100];
                snprintf(s, 100, "%02d/%02d/%04d %02d:%02d:%02d", tm2->tm_mday, tm2->tm_mon + 1, tm2->tm_year + 1900, tm2->tm_hour, tm2->tm_min, tm2->tm_sec);
                reqMonitoring->endTime_len = strlen(s);
                strcpy(reqMonitoring->endTime, s);
                reqStruct = tableToStruct(reqMonitoring, reqStruct);
                requestMonitoringDataTable_create_row(&index, reqStruct);
                /*Copy endTime to requestControl if it's currently empty*/
                reqControl = getControlTableID(reqMonitoring->requestControlID);
                if (reqControl->endControlTime_len == 0)
                {
                    requestStruct *aux = (requestStruct *)malloc(sizeof(requestStruct));
                    aux = reqControlConvert(reqControl, aux);
                    aux->endTime = malloc(sizeof(char) * reqMonitoring->endTime_len);
                    strcpy(aux->endTime, reqMonitoring->endTime);
                    int insertControl = insertControlRow(aux);
                    free(aux);
                    reqControl = getControlTableID(reqMonitoring->requestControlID);
                }
            }
            strncpy(hour, reqMonitoring->waitTime, 2);
            strncpy(min, reqMonitoring->waitTime + 3, 2);
            min[2] = '\0';
            hour[2] = '\0';
            strcpy(timestamp, reqMonitoring->startTime);
            tm2 = convertTime(tm2, timestamp);
            tm2 = addToTime(tm2, atoi(hour), atoi(min));
            /*WaitTime is reached, proceed with setting*/
            if (compareTimeStamp(tm, tm2) != 1)
            {
                index_oid[0] = reqMonitoring->requestID;
                index.oids = (oid *)&index_oid;
                index.len = 1;
                reqMonitoring->status = 1;
                if (reqMonitoring->requestStatisticsID != 0)
                {
                    statisticsStruct *statStruct = (statisticsStruct *)malloc(sizeof(statisticsStruct));
                    statStruct->duration = malloc(sizeof(char) * reqMonitoring->durationTime_len);
                    /*Find first free statistics ID*/
                    reqMonitoring->requestStatisticsID = firstStatisticsEntry();
                    statStruct->statID = reqMonitoring->requestStatisticsID;
                    strcpy(statStruct->duration, reqMonitoring->durationTime);
                    statStruct->nOfSamples = 0;
                    statStruct->minValue = 9999;
                    statStruct->maxValue = -999;
                    statStruct->avgValue = 0;
                    int stat = insertStatisticsRow(statStruct);
                    free(statStruct);
                    if (stat != 0)
                        printf("Statistics insertion failed\n");
                }
                else
                    printf("No statistics\n");

                reqStruct = tableToStruct(reqMonitoring, reqStruct);
                requestMonitoringDataTable_create_row(&index, reqStruct);
            }
            break;
        default:
            printf("Undefined status\n");
            break;
        }
        free(min);
        free(hour);
        free(timestamp);
        free(tm2);
    }
    ITERATOR_RELEASE(it);
    free(reqStruct);
}

#ifdef requestMonitoringDataTable_CUSTOM_SORT
/************************************************************
 * keep binary tree to find context by name
 */
static int requestMonitoringDataTable_cmp(const void *lhs, const void *rhs);

/************************************************************
 * compare two context pointers here. Return -1 if lhs < rhs,
 * 0 if lhs == rhs, and 1 if lhs > rhs.
 */
static int
requestMonitoringDataTable_cmp(const void *lhs, const void *rhs)
{
    requestMonitoringDataTable_context *context_l =
        (requestMonitoringDataTable_context *)lhs;
    requestMonitoringDataTable_context *context_r =
        (requestMonitoringDataTable_context *)rhs;

    /*
     * check primary key, then secondary. Add your own code if
     * there are more than 2 keys
     */
    int rc;

    /*
     * TODO: implement compare. Remove this ifdef code and
     * add your own code here.
     */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR,
             "requestMonitoringDataTable_compare not implemented! Container order undefined\n");
    return 0;
#endif

    /*
     * EXAMPLE (assuming you want to sort on a name):
     *   
     * rc = strcmp( context_l->xxName, context_r->xxName );
     *
     * if(rc)
     *   return rc;
     *
     * TODO: fix secondary keys (or delete if there are none)
     *
     * if(context_l->yy < context_r->yy) 
     *   return -1;
     *
     * return (context_l->yy == context_r->yy) ? 0 : 1;
     */
}

/************************************************************
 * search tree
 */
/** TODO: set additional indexes as parameters */
requestMonitoringDataTable_context *
requestMonitoringDataTable_get(const char *name, int len)
{
    requestMonitoringDataTable_context tmp;

    /** we should have a custom container */
    netsnmp_assert(cb.container->next != NULL);

    /*
     * TODO: implement compare. Remove this ifdef code and
     * add your own code here.
     */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR, "requestMonitoringDataTable_get not implemented!\n");
    return NULL;
#endif

    /*
     * EXAMPLE:
     *
     * if(len > sizeof(tmp.xxName))
     *   return NULL;
     *
     * strncpy( tmp.xxName, name, sizeof(tmp.xxName) );
     * tmp.xxName_len = len;
     *
     * return CONTAINER_FIND(cb.container->next, &tmp);
     */
}
#endif
/************************************************************
 * Initializes the requestMonitoringDataTable module
 */
void init_requestMonitoringDataTable(void)
{
    requestMonitoringDataTable_context *ctx;
    netsnmp_index index;
    oid index_oid[2];
    initialize_table_requestMonitoringDataTable();

    requestMonitoringStruct *req = (requestMonitoringStruct *)malloc(sizeof(requestMonitoringStruct));
    req->reqID = 0;
    /*1894 até 1901*/
    req->requestMapID = 1898;
    req->statisticsRequestID = 1;
    req->savingMode = 0;
    req->sampleFreq = 10;
    req->maxDelay = -10;
    req->waitTime = "00:00:00";
    req->durationTime = "01:00:00";
    req->expireTime = "02:00:00";
    time_t t = time(NULL);
    struct tm *tm = localtime(&t);
    char s[100];
    char s1[100];
    snprintf(s, 100, "%02d/%02d/%04d %02d:%02d:%02d", tm->tm_mday, tm->tm_mon + 1, tm->tm_year + 1900, tm->tm_hour, tm->tm_min, tm->tm_sec);
    req->startTime = malloc(sizeof(char) * strlen(s));
    strcpy(req->startTime, s);
    char *hour = malloc(sizeof(char) * 3);
    char *min = malloc(sizeof(char) * 3);
    strncpy(hour, req->durationTime, 2);
    strncpy(min, req->durationTime + 3, 2);
    min[2] = '\0';
    hour[2] = '\0';
    struct tm *tm2 = (struct tm *)malloc(sizeof(struct tm));
    tm2 = deepCopyTM(tm, tm2);
    tm2 = addToTime(tm2, atoi(hour), atoi(min));
    snprintf(s1, 100, "%02d/%02d/%04d %02d:%02d:%02d", tm2->tm_mday, tm2->tm_mon + 1, tm2->tm_year + 1900, tm2->tm_hour, tm2->tm_min, tm2->tm_sec);
    req->endTime = malloc(sizeof(char) * strlen(s1));
    strcpy(req->endTime, s1);
    free(hour);
    free(min);
    free(tm2);
    req->maxNofSamples = 10;
    req->lastSampleID = 0;
    req->loopmode = 2;
    req->nofSamples = 0;
    req->status = 2;
    req->requestUser = "Utilizador teste";
    index_oid[0] = 0;
    index.oids = (oid *)&index_oid;
    index.len = 1;
    ctx = NULL;
    /* Search for it first. */
    ctx = CONTAINER_FIND(cb.container, &index);
    if (!ctx)
    {
        // No dice. We add the new row
        ctx = requestMonitoringDataTable_create_row(&index, req);
        CONTAINER_INSERT(cb.container, ctx);
    }
    free(req);
}

/**
 * the *_extract_index routine
 *
 * This routine is called when a set request is received for an index
 * that was not found in the table container. Here, we parse the oid
 * in the the individual index components and copy those indexes to the
 * context. Then we make sure the indexes for the new row are valid.
 */
int requestMonitoringDataTable_extract_index(requestMonitoringDataTable_context *ctx, netsnmp_index *hdr)
{
    /*
     * temporary local storage for extracting oid index
     *
     * extract index uses varbinds (netsnmp_variable_list) to parse
     * the index OID into the individual components for each index part.
     */
    netsnmp_variable_list var_requestID;
    int err;

    /*
     * copy index, if provided
     */
    if (hdr)
    {
        netsnmp_assert(ctx->index.oids == NULL);
        if ((hdr->len > MAX_OID_LEN) ||
            snmp_clone_mem((void *)&ctx->index.oids, hdr->oids,
                           hdr->len * sizeof(oid)))
        {
            return -1;
        }
        ctx->index.len = hdr->len;
    }

    /*
     * initialize variable that will hold each component of the index.
     * If there are multiple indexes for the table, the variable_lists
     * need to be linked together, in order.
     */
    memset(&var_requestID, 0x00, sizeof(var_requestID));
    var_requestID.type = ASN_UNSIGNED; /* type hint for parse_oid_indexes */
                                       /** TODO: link this index to the next, or NULL for the last one */
#ifdef TABLE_CONTAINER_TODO
    snmp_log(LOG_ERR, "requestMonitoringDataTable_extract_index index list not implemented!\n");
    return 0;
#else
    var_requestID.next_variable = NULL;
#endif

    /*
     * parse the oid into the individual index components
     */
    err = parse_oid_indexes(hdr->oids, hdr->len, &var_requestID);
    if (err == SNMP_ERR_NOERROR)
    {
        /*
        * copy index components into the context structure
        */
        ctx->requestID = *var_requestID.val.integer;

        /*
            * TODO: check index for valid values. For EXAMPLE:
            *
              * if ( *var_requestID.val.integer != XXX ) {
          *    err = -1;
          * }
          */
    }

    /*
     * parsing may have allocated memory. free it.
     */
    snmp_reset_var_buffers(&var_requestID);

    return err;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int requestMonitoringDataTable_can_delete(requestMonitoringDataTable_context *undo_ctx,
                                          requestMonitoringDataTable_context *row_ctx,
                                          netsnmp_request_group *rg)
{

    /*
     * TODO: check for other deletion requirements here
     */
    return 1;
}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index *requestMonitoringDataTable_delete_row(requestMonitoringDataTable_context *ctx)
{
    /* netsnmp_mutex_destroy(ctx->lock); */
    /*
    if (ctx->index.oids)
        free(ctx->index.oids);
    */
    free(ctx->data);

    /*
     * release header
     */
    free(ctx);

    return NULL;
}

/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void requestMonitoringDataTable_set_reserve1(netsnmp_request_group *rg)
{
    requestMonitoringDataTable_context *row_ctx =
        (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx =
        (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;
    int rc;

    /*
     * TODO: loop through columns, check syntax and lengths. For
     * columns which have no dependencies, you could also move
     * the value/range checking here to attempt to catch error
     * cases as early as possible.
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);

            break;

        case COLUMN_MONITORINGCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);

            break;
        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_int(var);
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_int(var);
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->startTime));
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->endTime));
            break;

        case COLUMN_WAITTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->waitTime));
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->durationTime));
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->expireTime));
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_uint(var);
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_int(var);
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            /* or possibly 'netsnmp_check_vb_int_range' */
            rc = netsnmp_check_vb_int(var);
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            /* or possibly 'netsnmp_check_vb_type_and_size' */
            rc = netsnmp_check_vb_type_and_max_size(var, ASN_OCTET_STR,
                                                    sizeof(row_ctx->requestUser));
            break;
        default: /** We shouldn't get here */
            rc = SNMP_ERR_GENERR;
            snmp_log(LOG_ERR, "unknown column in "
                              "requestMonitoringDataTable_set_reserve1\n");
        }

        if (rc)
            netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri, rc);
        rg->status = SNMP_MAX(rg->status, current->ri->status);
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

void requestMonitoringDataTable_set_reserve2(netsnmp_request_group *rg)
{
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;
    netsnmp_variable_list *var;
    int rc;

    rg->rg_void = rg->list->ri;

    /*
     * TODO: loop through columns, check for valid
     * values and any range constraints.
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        case COLUMN_MONITORINGCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_WAITTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( *var->val.integer != XXX ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            /*
                     * TODO: routine to check valid values
                     *
                     * EXAMPLE:
                     *
                    * if ( XXX_check_value( var->val.string, XXX ) ) {
                *    rc = SNMP_ERR_INCONSISTENTVALUE;
                *    rc = SNMP_ERR_BADVALUE;
                * }
                */
            break;
        default:               /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }

        if (rc)
            netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri, rc);
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void requestMonitoringDataTable_set_action(netsnmp_request_group *rg)
{
    netsnmp_variable_list *var;
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    /*
     * TODO: loop through columns, copy varbind values
     * to context structure for the row.
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->requestID = *var->val.integer;
            break;
        case COLUMN_MONITORINGCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->requestControlID = *var->val.integer;
            break;
        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->requestMapID = *var->val.integer;
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->requestStatisticsID = *var->val.integer;
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            row_ctx->savingMode = *var->val.integer;
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->samplingFrequency = *var->val.integer;
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            row_ctx->maxDelay = *var->val.integer;
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->startTime, var->val.string, var->val_len);
            row_ctx->startTime_len = var->val_len;
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->endTime, var->val.string, var->val_len);
            row_ctx->endTime_len = var->val_len;
            break;

        case COLUMN_WAITTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->waitTime, var->val.string, var->val_len);
            row_ctx->waitTime_len = var->val_len;
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->durationTime, var->val.string, var->val_len);
            row_ctx->durationTime_len = var->val_len;
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            memcpy(row_ctx->expireTime, var->val.string, var->val_len);
            row_ctx->expireTime_len = var->val_len;
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->maxNOfSamples = *var->val.integer;
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            row_ctx->lastSampleID = *var->val.integer;
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            row_ctx->loopMode = *var->val.integer;
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            row_ctx->status = *var->val.integer;
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            memcpy(row_ctx->requestUser, var->val.string, var->val_len);
            row_ctx->requestUser_len = var->val_len;
            break;
        default:               /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
    /*
     * TODO: if you have dependencies on other tables, this would be
     * a good place to check those, too.
     */
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void requestMonitoringDataTable_set_commit(netsnmp_request_group *rg)
{
    netsnmp_variable_list *var;
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;
        case COLUMN_MONITORINGCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;
        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_WAITTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            break;
        default:               /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void requestMonitoringDataTable_set_free(netsnmp_request_group *rg)
{
    netsnmp_variable_list *var;
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_MONITORINGCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_WAITTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            break;
        default: /** We shouldn't get here */
            break;
            /** should have been logged in reserve1 */
        }
    }
}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void requestMonitoringDataTable_set_undo(netsnmp_request_group *rg)
{
    netsnmp_variable_list *var;
    requestMonitoringDataTable_context *row_ctx = (requestMonitoringDataTable_context *)rg->existing_row;
    requestMonitoringDataTable_context *undo_ctx = (requestMonitoringDataTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next)
    {

        var = current->ri->requestvb;

        switch (current->tri->colnum)
        {

        case COLUMN_REQUESTID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_MONITORINGCONTROLID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTMAPID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_REQUESTSTATISTICSID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_SAVINGMODE:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_SAMPLINGFREQUENCY:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_MAXDELAY:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_STARTTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_ENDTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_WAITTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_DURATIONTIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_EXPIRETIME:
            /** OBUDateandTime = ASN_OCTET_STR */
            break;

        case COLUMN_MAXNOFSAMPLES:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LASTSAMPLEID:
            /** UNSIGNED32 = ASN_UNSIGNED */
            break;

        case COLUMN_LOOPMODE:
            /** INTEGER = ASN_INTEGER */
            break;
        case COLUMN_STATUS:
            /** INTEGER = ASN_INTEGER */
            break;

        case COLUMN_REQUESTUSER:
            /** OCTET STRING = ASN_OCTET_STR */
            break;

        default:               /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}
requestMonitoringDataTable_context *requestMonitoringDataTable_create_row_default(netsnmp_index *hdr)
{
    requestMonitoringDataTable_context *ctx = SNMP_MALLOC_TYPEDEF(requestMonitoringDataTable_context);
    if (!ctx)
        return NULL;
    if (requestMonitoringDataTable_extract_index(ctx, hdr))
    {
        free(ctx->index.oids);
        free(ctx);
        return NULL;
    }
    ctx->status = 2;
    ctx->samplingFrequency = 0;
    ctx->maxDelay = 0;
    ctx->lastSampleID = 0;
    ctx->nOfSamples = 0;
    ctx->endTime_len = 0;
    ctx->startTime_len = 0;
    ctx->waitTime_len = 0;
    ctx->expireTime_len = 0;
    ctx->durationTime_len = 0;
    return ctx;
}
/************************************************************
 *
 * Initialize the requestMonitoringDataTable table by defining its contents and how it's structured
 */
void initialize_table_requestMonitoringDataTable(void)
{
    netsnmp_table_registration_info *table_info;

    if (my_handler)
    {
        snmp_log(LOG_ERR, "initialize_table_requestMonitoringDataTable_handler called again\n");
        return;
    }

    memset(&cb, 0x00, sizeof(cb));

    /** create the table structure itself */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

    my_handler = netsnmp_create_handler_registration("requestMonitoringDataTable",
                                                     netsnmp_table_array_helper_handler,
                                                     requestMonitoringDataTable_oid,
                                                     requestMonitoringDataTable_oid_len,
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info)
    {
        snmp_log(LOG_ERR, "malloc failed in "
                          "initialize_table_requestMonitoringDataTable_handler\n");
        return; /** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */
    /*
     * TODO: add any external indexes here.
     */

    /*
     * internal indexes
     */
    /** index: requestID */
    netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);

    table_info->min_column = requestMonitoringDataTable_COL_MIN;
    table_info->max_column = requestMonitoringDataTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
    cb.get_value = requestMonitoringDataTable_get_value;
    cb.container = netsnmp_container_find("requestMonitoringDataTable_primary:"
                                          "requestMonitoringDataTable:"
                                          "table_container");
#ifdef requestMonitoringDataTable_CUSTOM_SORT
    netsnmp_container_add_index(cb.container,
                                netsnmp_container_find("requestMonitoringDataTable_custom:"
                                                       "requestMonitoringDataTable:"
                                                       "table_container"));
    cb.container->next->compare = requestMonitoringDataTable_cmp;
#endif
    cb.can_set = 1;
    cb.duplicate_row = (UserRowMethod *)requestMonitoringDataTable_duplicate_row;
    cb.delete_row = (UserRowMethod *)requestMonitoringDataTable_delete_row;
    cb.row_copy = (Netsnmp_User_Row_Operation *)requestMonitoringDataTable_row_copy;
    cb.can_delete = (Netsnmp_User_Row_Action *)requestMonitoringDataTable_can_delete;
    cb.create_row = (UserRowMethod *)requestMonitoringDataTable_create_row_default;
    cb.set_reserve1 = requestMonitoringDataTable_set_reserve1;
    cb.set_reserve2 = requestMonitoringDataTable_set_reserve2;
    cb.set_action = requestMonitoringDataTable_set_action;
    cb.set_commit = requestMonitoringDataTable_set_commit;
    cb.set_free = requestMonitoringDataTable_set_free;
    cb.set_undo = requestMonitoringDataTable_set_undo;
    DEBUGMSGTL(("initialize_table_requestMonitoringDataTable",
                "Registering table requestMonitoringDataTable "
                "as a table array\n"));
    netsnmp_table_container_register(my_handler, table_info, &cb,
                                     cb.container, 1);
}

/************************************************************
 * requestMonitoringDataTable_get_value
 *
 * This routine is called for get requests to copy the data
 * from the context to the varbind for the request. If the
 * context has been properly maintained, you don't need to
 * change in code in this fuction.
 */
int requestMonitoringDataTable_get_value(
    netsnmp_request_info *request,
    netsnmp_index *item,
    netsnmp_table_request_info *table_info)
{
    netsnmp_variable_list *var = request->requestvb;
    requestMonitoringDataTable_context *context = (requestMonitoringDataTable_context *)item;
    switch (table_info->colnum)
    {

    case COLUMN_REQUESTID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->requestID,
                                 sizeof(context->requestID));
        break;
    case COLUMN_MONITORINGCONTROLID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->requestControlID,
                                 sizeof(context->requestControlID));
        break;
    case COLUMN_REQUESTMAPID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->requestMapID,
                                 sizeof(context->requestMapID));
        break;

    case COLUMN_REQUESTSTATISTICSID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->requestStatisticsID,
                                 sizeof(context->requestStatisticsID));
        break;

    case COLUMN_SAVINGMODE:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->savingMode,
                                 sizeof(context->savingMode));
        break;

    case COLUMN_SAMPLINGFREQUENCY:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->samplingFrequency,
                                 sizeof(context->samplingFrequency));
        break;

    case COLUMN_MAXDELAY:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->maxDelay,
                                 sizeof(context->maxDelay));
        break;

    case COLUMN_STARTTIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->startTime,
                                 context->startTime_len);
        break;

    case COLUMN_ENDTIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->endTime,
                                 context->endTime_len);
        break;

    case COLUMN_WAITTIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->waitTime,
                                 context->waitTime_len);
        break;

    case COLUMN_DURATIONTIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->durationTime,
                                 context->durationTime_len);
        break;

    case COLUMN_EXPIRETIME:
        /** OBUDateandTime = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->expireTime,
                                 context->expireTime_len);
        break;

    case COLUMN_MAXNOFSAMPLES:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->maxNOfSamples,
                                 sizeof(context->maxNOfSamples));
        break;

    case COLUMN_LASTSAMPLEID:
        /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *)&context->lastSampleID,
                                 sizeof(context->lastSampleID));
        break;

    case COLUMN_LOOPMODE:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->loopMode,
                                 sizeof(context->loopMode));
        break;

    case COLUMN_NOFSAMPLES:
        /** COUNTER = ASN_COUNTER */
        snmp_set_var_typed_value(var, ASN_COUNTER,
                                 (char *)&context->nOfSamples,
                                 sizeof(context->nOfSamples));
        break;

    case COLUMN_STATUS:
        /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->status,
                                 sizeof(context->status));
        break;

    case COLUMN_REQUESTUSER:
        /** OCTET STRING = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *)&context->requestUser,
                                 context->requestUser_len);
        break;
    default: /** We shouldn't get here */
        snmp_log(LOG_ERR, "unknown column in "
                          "requestMonitoringDataTable_get_value\n");
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

/************************************************************
 * requestMonitoringDataTable_get_by_idx
 */
const requestMonitoringDataTable_context *
requestMonitoringDataTable_get_by_idx(netsnmp_index *hdr)
{
    return (const requestMonitoringDataTable_context *)
        CONTAINER_FIND(cb.container, hdr);
}
/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated requestMonitoringDataTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
requestMonitoringDataTable_context *requestMonitoringDataTable_create_row(netsnmp_index *hdr, requestMonitoringStruct *req)
{
    requestMonitoringDataTable_context *ctx = SNMP_MALLOC_TYPEDEF(requestMonitoringDataTable_context);
    if (!ctx)
        return NULL;
    if (requestMonitoringDataTable_extract_index(ctx, hdr))
    {
        free(ctx->index.oids);
        free(ctx);
        return NULL;
    }
    ctx->index.oids = ctx->oid_buf;
    ctx->oid_buf[0] = req->reqID;
    ctx->index.len = 1;
    ctx->requestID = (long unsigned int)req->reqID;
    ctx->requestControlID = (long unsigned int)req->requestControlID;
    ctx->requestMapID = (long unsigned int)req->requestMapID;
    ctx->requestStatisticsID = (long unsigned int)req->statisticsRequestID;
    ctx->savingMode = req->savingMode;
    ctx->samplingFrequency = req->sampleFreq;
    ctx->maxDelay = req->maxDelay;

    strcpy(ctx->startTime, req->startTime);
    ctx->startTime_len = strlen(req->startTime);
    strcpy(ctx->endTime, req->endTime);
    ctx->endTime_len = strlen(req->endTime);
    strcpy(ctx->waitTime, req->waitTime);
    ctx->waitTime_len = strlen(req->waitTime);
    strcpy(ctx->durationTime, req->durationTime);
    ctx->durationTime_len = strlen(req->durationTime);
    strcpy(ctx->expireTime, req->expireTime);
    ctx->expireTime_len = strlen(req->expireTime);

    ctx->maxNOfSamples = (long unsigned int)req->maxNofSamples;
    ctx->lastSampleID = (long unsigned int)req->lastSampleID;
    ctx->loopMode = req->loopmode;
    ctx->nOfSamples = req->nofSamples;
    ctx->status = req->status;
    strcpy(ctx->requestUser, req->requestUser);
    ctx->requestUser_len = strlen(req->requestUser);
    return ctx;
}
/************************************************************
 * the *_duplicate row routine
 */
requestMonitoringDataTable_context *
requestMonitoringDataTable_duplicate_row(requestMonitoringDataTable_context *row_ctx)
{
    requestMonitoringDataTable_context *dup;

    if (!row_ctx)
        return NULL;

    dup = SNMP_MALLOC_TYPEDEF(requestMonitoringDataTable_context);
    if (!dup)
        return NULL;

    if (requestMonitoringDataTable_row_copy(dup, row_ctx))
    {
        free(dup);
        dup = NULL;
    }

    return dup;
}
/************************************************************
 * the *_row_copy routine
 */
int requestMonitoringDataTable_row_copy(requestMonitoringDataTable_context *dst, requestMonitoringDataTable_context *src)
{
    if (!dst || !src)
        return 1;

    /*
     * copy index, if provided
     */
    if (dst->index.oids)
        free(dst->index.oids);
    if (snmp_clone_mem((void *)&dst->index.oids, src->index.oids,
                       src->index.len * sizeof(oid)))
    {
        dst->index.oids = NULL;
        return 1;
    }
    dst->index.len = src->index.len;

    /*
     * copy components into the context structure
     */
    dst->requestID = src->requestID;
    dst->requestControlID = src->requestControlID;
    dst->requestMapID = src->requestMapID;
    dst->requestStatisticsID = src->requestStatisticsID;
    dst->savingMode = src->savingMode;
    dst->samplingFrequency = src->samplingFrequency;
    dst->maxDelay = src->maxDelay;
    memcpy(dst->startTime, src->startTime, src->startTime_len);
    dst->startTime_len = src->startTime_len;
    memcpy(dst->endTime, src->endTime, src->endTime_len);
    dst->endTime_len = src->endTime_len;
    memcpy(dst->waitTime, src->waitTime, src->waitTime_len);
    dst->waitTime_len = src->waitTime_len;
    memcpy(dst->durationTime, src->durationTime, src->durationTime_len);
    dst->durationTime_len = src->durationTime_len;
    memcpy(dst->expireTime, src->expireTime, src->expireTime_len);
    dst->expireTime_len = src->expireTime_len;
    dst->maxNOfSamples = src->maxNOfSamples;
    dst->lastSampleID = src->lastSampleID;
    dst->loopMode = src->loopMode;
    dst->nOfSamples = src->nOfSamples;
    dst->status = src->status;
    memcpy(dst->requestUser, src->requestUser, src->requestUser_len);
    dst->requestUser_len = src->requestUser_len;
    return 0;
}
